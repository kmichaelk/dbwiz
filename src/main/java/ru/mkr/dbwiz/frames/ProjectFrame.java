package ru.mkr.dbwiz.frames;

import ru.mkr.dbwiz.Main;
import ru.mkr.dbwiz.ProjectExecutor;
import ru.mkr.dbwiz.engine.ScriptEngine;
import ru.mkr.dbwiz.engine.ScriptEngineCompat;
import ru.mkr.dbwiz.enums.ProjectExecutionState;
import ru.mkr.dbwiz.utilities.HookedOutputStream;
import ru.mkr.dbwiz.utilities.Utility;
import ru.mkr.dbwiz.exceptions.EngineInitializationException;
import ru.mkr.dbwiz.handlers.ProjectExecutionHandler;
import ru.mkr.dbwiz.managers.ProjectManager;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.border.TitledBorder;
import java.awt.*;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.io.PrintStream;
import java.util.HashMap;
import java.util.Map;
import java.util.function.Consumer;

/*
 * Created on 19/10/20
 * (c) Mikhail K., 2020
 */
public class ProjectFrame extends JFrame {

    public static final Map<String, ProjectFrame> RUNNING_PROJECT_FRAMES = new HashMap<>();

    /* ---------------------------------- */
    private JPanel rootPanel;
    private JTextArea logArea;
    private JProgressBar progressBar;
    private JButton button;
    private JLabel statusLabel;
    /* ---------------------------------- */

    private final String projectName;

    private final Thread executionThread;
    private final MessageListener messageListener;
    private final PrintStream printStream;
    private final ProjectExecutionHandler handler;

    private ScriptEngine engine = null;
    private boolean executionInterrupted = false;
    private ProjectExecutionState currentState;

    public ProjectFrame(String projectPath) {
        super(ProjectManager.getProjectNameFromPath(projectPath) + " - " + Main.NAME);
        projectName = ProjectManager.getProjectNameFromPath(projectPath);

        ProjectManager.RUNNING_PROJECTS.add(projectPath);
        RUNNING_PROJECT_FRAMES.put(projectPath, this);
        addWindowListener(new WindowAdapter() {
            @Override
            public void windowClosed(WindowEvent e) {
                ProjectManager.RUNNING_PROJECTS.remove(projectPath);
                RUNNING_PROJECT_FRAMES.remove(projectPath);
            }
        });
        setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
        setContentPane(rootPanel);

        messageListener = new MessageListener();
        printStream = HookedOutputStream.newPrintStream(messageListener);
        handler = new UIProjectExecutionHandler();

        logArea.setEditable(false);
        logArea.setBorder(new EmptyBorder(5, 5, 5, 5));

        getRootPane().setDefaultButton(button);

        setSize(450, 450);
        setLocationRelativeTo(null);
        setResizable(false);

        setVisible(true);

        executionThread = new Thread(() -> {
            try {
                ProjectExecutor.runProject(
                        projectPath,
                        handler,
                        printStream
                );
            } catch (Exception ex) {
                handler.onProjectExecutionException(ex);
            }
            while (engine != null && !executionInterrupted) {
                try {
                    wait(5000L);
                } catch (InterruptedException iex) {
                    System.out.print("Во время ожидания завершения выполнения проекта произошла ошибка");
                    //Thread.currentThread().stop();
                    break;
                }
            }
            if (engine != null) {
                engine.shutdown();
                engine = null;
            }
        }, "Project Execution Thread");

        button.addActionListener((e) -> {
            if (currentState == ProjectExecutionState.FINISHED || currentState == ProjectExecutionState.INTERRUPTED) {
                dispose();
            } else {
                handler.interruptProjectExecution();
                printStream.println(ProjectExecutor.OUTPUT_TEXT_SEPARATOR + "\nВыполнение проекта прервано пользователем\n");
            }
        });

        executionThread.start();
    }

    {
// GUI initializer generated by IntelliJ IDEA GUI Designer
// >>> IMPORTANT!! <<<
// DO NOT EDIT OR ADD ANY CODE HERE!
        $$$setupUI$$$();
    }

    /**
     * Method generated by IntelliJ IDEA GUI Designer
     * >>> IMPORTANT!! <<<
     * DO NOT edit this method OR call it in your code!
     *
     * @noinspection ALL
     */
    private void $$$setupUI$$$() {
        rootPanel = new JPanel();
        rootPanel.setLayout(new BorderLayout(0, 0));
        rootPanel.setBorder(BorderFactory.createTitledBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5), null, TitledBorder.DEFAULT_JUSTIFICATION, TitledBorder.DEFAULT_POSITION, null, null));
        final JPanel panel1 = new JPanel();
        panel1.setLayout(new BorderLayout(0, 0));
        rootPanel.add(panel1, BorderLayout.SOUTH);
        final JSeparator separator1 = new JSeparator();
        panel1.add(separator1, BorderLayout.NORTH);
        final JPanel panel2 = new JPanel();
        panel2.setLayout(new BorderLayout(0, 5));
        panel1.add(panel2, BorderLayout.CENTER);
        panel2.setBorder(BorderFactory.createTitledBorder(BorderFactory.createEmptyBorder(5, 0, 0, 0), null, TitledBorder.DEFAULT_JUSTIFICATION, TitledBorder.DEFAULT_POSITION, null, null));
        progressBar = new JProgressBar();
        progressBar.setIndeterminate(true);
        progressBar.setValue(0);
        panel2.add(progressBar, BorderLayout.CENTER);
        button = new JButton();
        button.setText("Прервать выполнение проекта");
        panel2.add(button, BorderLayout.SOUTH);
        statusLabel = new JLabel();
        statusLabel.setHorizontalAlignment(0);
        statusLabel.setHorizontalTextPosition(0);
        statusLabel.setText("Инициализация...");
        panel2.add(statusLabel, BorderLayout.NORTH);
        final JScrollPane scrollPane1 = new JScrollPane();
        rootPanel.add(scrollPane1, BorderLayout.CENTER);
        logArea = new JTextArea();
        scrollPane1.setViewportView(logArea);
    }

    /**
     * @noinspection ALL
     */
    public JComponent $$$getRootComponent$$$() {
        return rootPanel;
    }

    private class UIProjectExecutionHandler implements ProjectExecutionHandler {

        @Override
        public String getProjectName() {
            return projectName;
        }

        @Override
        public void interruptProjectExecution() {
            SwingUtilities.invokeLater(() -> onProjectStateChange(ProjectExecutionState.INTERRUPTED));
            executionInterrupted = true;
            //if(engine != null) {
            //    engine.kill();
            //    engine = null;
            //}
            //executionThread.interrupt();
            //executionThread.stop();
        }

        @Override
        public void onProjectExecutionInterruptRequest(int exitCode) {
            Thread.dumpStack();
            print(ProjectExecutor.OUTPUT_TEXT_SEPARATOR + "\nПроект запросил остановку работы" +
                    (exitCode == 0 ? "" : ", код выхода: " + exitCode));
            interruptProjectExecution();
        }

        @Override
        public void onProjectEngineInitialized(ScriptEngine engine) {
            ProjectFrame.this.engine = engine;
        }

        @Override
        public void onProjectStateChange(ProjectExecutionState state) {
            currentState = state;
            progressBar.setIndeterminate(!state.isLast());
            if (state.isLast()) {
                progressBar.setValue(state == ProjectExecutionState.FINISHED ?
                        progressBar.getMaximum() : progressBar.getMinimum());
                button.setText("Закрыть");
                System.gc();
                engine = null;
            }
            onProjectStatusChange(state.toString());
            //statusLabel.setText(state + " (" + state.getNumber() + "/" + ProjectExecutionState.values().length + ")");
        }

        @Override
        public void onProjectStatusChange(String status) {
            SwingUtilities.invokeLater(() -> statusLabel.setText(status));
        }

        @Override
        public void onProjectProgressChange(int progress) {
            SwingUtilities.invokeLater(() -> {
                if (progressBar.isIndeterminate()) {
                    progressBar.setIndeterminate(false);
                }
                progressBar.setValue(progress);
            });
        }

        @Override
        public void onProjectExecutionTimeCalculated(long time) {
            statusLabel.setText(ProjectExecutionState.FINISHED + " (" + Utility.millisecondsToString(time) + ")");
        }

        @Override
        public void onProjectExecutionException(Exception ex) {
            if (executionInterrupted) return;
            String errorMessage;

            String separator;
            boolean isEngineException = ScriptEngineCompat.isEngineException(ex);
            if (isEngineException && ex.getCause() != null && ex.getCause() instanceof Exception) {
                onProjectExecutionException(((Exception) ex.getCause()));
                separator = "";
            } else {
                separator = ProjectExecutor.OUTPUT_TEXT_SEPARATOR;
            }

            if (!isEngineException && ex instanceof EngineInitializationException) {
                errorMessage = "Ошибка при инициализации движка";
            } else {
                errorMessage = "При выполнении проекта произошла ошибка "
                        + (isEngineException ? "движка" : "модуля");
            }

            print("\n" + separator);
            print("\n" + errorMessage + ":\n");
            print((ex.getMessage() == null || ex.getMessage().isEmpty()) ? "Неизвестная ошибка" : ex.getMessage());
            ex.printStackTrace();
            print("\n");
            interruptProjectExecution();
        }
    }

    private class MessageListener implements Consumer<String> {
        @Override
        public void accept(String s) {
            logArea.append(s);
            logArea.setCaretPosition(logArea.getDocument().getLength());
        }
    }

    private void print(Object o) {
        printStream.print(o);
    }
}
